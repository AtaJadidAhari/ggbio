%\VignetteIndexEntry{An Introduction to ggbio}
%\VignetteDepends{}
%\VignetteKeywords{visualization utilities}
%\VignettePackage{biovizBase}
\documentclass[10pt]{article}

% \usepackage{times}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}

\SweaveOpts{width = 5, height = 4.5}

\textwidth=6.5in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\IRanges}{\Rpackage{IRanges}}
\newcommand{\biovizBase}{\Rpackage{biovizBase}}
\newcommand{\ggbio}{\Rpackage{ggbio}}
\newcommand{\visnab}{\Rpackage{visnab}}
\newcommand{\ggplot}{\Rpackage{ggplot2}}
\newcommand{\grid}{\Rpackage{grid}}
\newcommand{\gridExtra}{\Rpackage{gridExtra}}
\newcommand{\qplot}{\Rfunction{qplot}}

\title{An Introduction to \ggbio{}}
\author{Tengfei Yin}
\date{\today}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

<<options,echo=FALSE>>=
options(width=72)
@

\section{Introduction}

The \R{} package, \ggbio{}, provided a toolkit for visualizing
biological data, using static \R{} graphics. We mainly focus on
visualizing sequencing data, and annotation tracks, but not just
limited to it. We also try to implement some most used graphics and at
the same time explore more types of new graphics. For example, we have
implement \emph{Manhattan plot} for GWAS study, stacked overview for
exploring distribution of events cross all chromosomes, splicing
summary for summarizing alternative splice events, etc. It's just a
start, we hope to provide a static gallary for biologists and analyst,
and prototyping for interactive graphics project like \visnab{}.
% DI: Explain what is meant by biological data(Done)

This package extends the \ggplot{}
package\footnote{\url{http://had.co.nz/ggplot2/}}, which provides
elegant static graphics, based on the grammar of graphics. The syntax
and style of commands follows that of \ggplot{}. For those plots which
require a low level manipulation on graphics some plots are enhanced
using \grid{} or \gridExtra{}.


The goal is to provide high quality graphics for both analysis and
publication purposes, requiring some rules:
\begin{itemize} \itemsep 0in
\item Be general. Try to focus on most asked questions and provide
  most used types of graphics at first. % DI: explain what you mean here.(done)
\item Be object-oriented, by providing a generic function, eg
  \Robject{qplot}, which automatically can handle and plot different
  \R{} biological data objects in \software{Bioconductor} project.
\item To use \ggplot{} to develop graphics much as as possible, but
  hide the complexity. Most functions return a \Robject{ggplot}
  object, which allow users to further enhance this object, for
  example, add/change labels, changing color scheme, etc.
\item Be easy-to-use and user-friendly. For specific questions or most
  used graphics, we provide simple functions to that make the necessary
  graphics.
\end{itemize}

\section{Some Details of  \ggplot{}}

Extensive details about \ggplot{} are available in the on-line
documentation, or the web site
\url{http://had.co.nz/ggplot2/geom_point.html}. The key pieces of
describing a plot are these:

\begin{description} \itemsep 0in
\item [data] object to be visualized
\item [geoms] how elements of the data are mapped into the plot (points, lines, ...)
\item [statistics] transformations necessary on the data, eg binning for a histogram
\item [scale] scaling data values for plotting, matching colors to values, generating legends
\item [coordinates] axes, coordinate transformations, eg polar, and aspect ratios
  plot
%\item [display] Produces the picture, but should also provide interactivity (brushing, drill down, zooming)
\end{description}

There are very \textbf{important} differences between \ggbio{} and
\ggplot{}:
\begin{itemize} \itemsep 0in
\item The horizontal axis in \ggbio{}, for most plots, will be genomic
  coordinates. You can only specify the \emph{x} to
  be \emph{start, end, midpoint} describing interval data with width
  larger than 1. % DI: Maybe explain what you mean by protein space?(done, remove)
\item Facetting of the graphics, can only be done by \textbf{seqnames}
  or region on a chromosome. If \textbf{seqnames} is in the data
  structure, it automatically is used for facetting.
\end{itemize}

\section{Generic Visualization Method}

In the spirit of being general and object-oriented, following the
syntax of \ggplot{}, we redefine the \emph{quick plot} function
\qplot{} in \ggplot{} package, as a \textbf{S4} generic function. Then
the \qplot{} function could automatically and appropriately plot
different R objects. For each pbject type a new \textbf{geom} is
defined.

In the following section, we will introduce how to use \qplot{} to
plot different types of data to generate different displays.

\subsection{Plotting a \Robject{data.frame} }
This is a wrapper around the original \qplot{} function. when reading
in \Robject{data.frame} or \Robject{matrix} object, you can use
\qplot{} as usual without any change, it essentially just call
ggplot2::qplot.

% DI: Put the data(hg19IdeogramCyto) line in the correct place(done)
@ 
<<loading, eval = FALSE>>=
library(ggbio)
@ %def 

% \begin{figure}[h!t!p]
%   \centering
<<ggbio-loading, fig = FALSE, eval = FALSE>>=
p <- qplot(data = mtcars, mpg, cyl)
print(p)
@ %def 
%   \caption{qplot for data.frame}
%   \label{fig:qplot-data.frame}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.55\textwidth]{intro-ggbio-loading.pdf}
\caption{If the data object is simply an R \Robject{data.frame}, the
  \Robject{qplot} defaults are used, which is the point geom.}
  \label{fig:qplot-data.frame}
\end{figure}

% DI: Expand all of the captions for the figures, like this one. Explain
% what the user is expected to learn from the plot.

\subsection{Plotting \Robject{GRanges} object}
A \Robject{GRanges} object is defined in \Rpackage{GenomicRanges}
package. It is one of the most important data structures coding
genomic information, organizing genomic data as intervals. Three
required fields for this object is \Robject{seqnames} for chromosome
name, \Robject{ranges} for interval position, \Robject{strand} for
storing direction of strand for particular interval, including
\textbf{+,-,*}.Currently \R{} does not have any convenient functions
for visualizing interval objects.
% DI: Explain what strand is(done)

\subsubsection{Sample \Robject{Granges} object}
Let's first create a sample \Robject{GRanges} object that can be used
for following examples. We generate data, mimicking paired RNA-seq
data, that contains 1000 rows, 3 chromosomes, and meta data of
grouping and pairing information.


@ 
<<GRanges-sample, eval = FALSE>>=
set.seed(1)
N <- 1000
library(GenomicRanges)
gr <- GRanges(seqnames = 
              sample(c("chr1", "chr2", "chr3"),
                     size = N, replace = TRUE),
              IRanges(
                      start = sample(1:300, size = N, replace = TRUE),
                      width = sample(70:75, size = N,replace = TRUE)),
              strand = sample(c("+", "-", "*"), size = N, 
                replace = TRUE),
              value = rnorm(N, 10, 3), score = rnorm(N, 100, 30),
              group = sample(c("Normal", "Tumor"), 
                size = N, replace = TRUE),
              pair = sample(letters, size = N, 
                replace = TRUE))
@ %def 

\subsubsection{Supported Geoms}

For \Robject{GRanges} objects we support following \emph{geoms}:

\begin{description} \itemsep 0in
\item[full] Show the full stacked interval, a set of rectangles. Default.
\item[segment] Show full stacked interval, as a set of segments.
\item[line] Show line, which the user needs to provide.
\item[coverage.line] Show coverage by using line.
\item[coverage.polygon] Show coverage by using polygon.
\item[reduce]  Show reduced \Robject{GRanges} object.
\item[disjoin] Show disjoint \Robject{GRanges} object.
\item[histogram] Show histogram.
% \item[splice] A wrapper around function \Rfunction{plotSpliceSum}, so
%   when you set to \Rfunarg{geom} equals to \emph{splice}, you have to
%   to provide arguments \Rfunarg{model}. 
\end{description}

This code generates the default plot of a \Robject{GRanges} object
(Figure \ref{fig:qplot-gr-full}). It uses the \texttt{full geom}, showing
the data as stacked intervals, automatically facetted by
\textbf{seqnames} (chromosome) and colored by the strand.

% \begin{figure}[h!t!p]
%   \centering
@ 
<<qplot-gr-full, fig = FALSE, eval = FALSE>>=
p <- qplot(gr)
@ %def   
%   \caption{qplot for GRanges as geom full}
%   \label{fig:qplot-gr-full}
% \end{figure}
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-qplot-gr-full.png}
\caption{qplot for GRanges as \texttt{geom full}. We could see the
  plot is shown in three columns which facet by seqnames, and colored
  by strand. The small rectangles are those interval data described in
  our test \Robject{GRanges} object. We can imagine they are short
  reads on specific region of the genome}
  \label{fig:qplot-gr-full}
\end{figure}

% DI: Can you regenerate the plots so that the text on the axes doesn't
% overlap?  Also explain what you learn from this plot: the data was
% simulated from uniform, which you see because the stacks are
% somewhat level, and the strand variable was randomly generated so
% there is no pattern to the colors

%As we could see from Figure \ref{fig:qplot-gr-full}, the default is
%\emph{automatically} facet by existing \textbf{seqnames} in the
%\Robject{GRanges} object. We can use \Rfunarg{nrow} and \Rfunarg{ncol} 
%to control the wrapping. 

%\begin{figure}[h!t!p]
%  \centering
%@ 
%<<qplot-gr-full-nrow1, fig = FALSE, eval = FALSE>>=
%p <- qplot(gr, nrow = 1)
%print(p)
%@ %def   
%  \caption{qplot for GRanges as geom full}
%  \label{fig:qplot-gr-full-nrow1}
%\end{figure}

%We we get the \Robject{ggplot} object, we could use all features from
%\ggplot{} package to manupuate this plot. Here we show a simple theme
%change.

In this next display (Figure \ref{fig:qplot-gr-full-themebw}), a
different theme was used to make the background white.

% \begin{figure}[h!t!p]
%   \centering
@ 
<<qplot-gr-full-themebw, fig = FALSE, eval = FALSE>>=
p <- p + theme_bw()
print(p)
@ %def   
%   \caption{qplot for GRanges as geom full}
%   \label{fig:qplot-gr-full-themebw}
% \end{figure}
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-qplot-gr-full-themebw.png}
\caption{qplot for GRanges as geom full. The theme for this graphic is
  set to blank}
  \label{fig:qplot-gr-full-themebw}
\end{figure}

In this next plot, the \texttt{coverage.p geom} is used (Figure
\ref{fig:qplot-gr-cov-line}).

% \begin{figure}[h!t!p]
%   \centering
@ 
<<qplot-gr-cov-line, fig = FALSE, eval = FALSE>>=
p <- qplot(gr, nrow = 1, geom = "coverage.p")
p <- p + geom_hline(yintercept = 40, color = "red", 
    size = 1)
print(p)
@ %def   
%   \caption{qplot for GRanges as geom full}
%   \label{fig:qplot-gr-cov-line}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-qplot-gr-cov-line.png}
\caption{qplot for GRanges as \texttt{geom coverage.polygon}, the
  redline shows the artificial cutoff.}
  \label{fig:qplot-gr-cov-line}
\end{figure}

And let's plot all other geoms together by \Rfunction{grid.arrange} from
package \Rpackage{gridExtra} (Figure \ref{fig:all-geom-gr}).

% \begin{figure}[h!b!t!p]
%   \centering
@
<<qplot-gr-all, fig = FALSE, eval = FALSE>>=
gr.sub <- gr[seqnames(gr) == "chr1"] #or 
p1 <- qplot(gr.sub, geom = "full") + opts(title = "full")
p2 <- qplot(gr.sub, geom = "point", y = value) + opts(title = "point")
p3 <- qplot(gr.sub, geom = "line", y = value) + opts(title = "line")
p4 <- qplot(gr.sub, geom = "coverage.line") + opts(title = "coverage.line")   
p5 <- qplot(gr.sub, geom = "coverage.polygon") + opts(title = "coverage.polygon")   
p6 <- qplot(gr.sub, geom = "reduce") + opts(title = "reduce")   
p7 <- qplot(gr.sub, geom = "disjoin") + opts(title = "disjoin")      
p8 <- qplot(gr.sub, geom = "histogram") + opts(title = "histogram")      
library(gridExtra)
grid.arrange(p1, p2, p3, p4, p5, p6, p7 ,p8, ncol = 2)
@ %def     
%   \caption{All common geoms(except splice) for GRanges object}
%   \label{fig:all-geom-gr}
% \end{figure}
\begin{figure}[h!b!t!p]
  \centering
\includegraphics[width = 0.7\textwidth]{intro-qplot-gr-all.png}
  \caption{All common geoms(except splice) for GRanges object}
  \label{fig:all-geom-gr}
\end{figure}

\subsubsection{Layout}
Figure \ref{fig:gr-layout-nrow} shows, when you simply facet by
seqnames as default, your can use \Rfunarg{nrow} and \Rfunarg{ncol} to
control the layout of the graphic. It ensentially use
\Rfunction{facet\_wrap} in \ggplot{} automaticaly.

@ 
<<qplot-layout-nrow, fig = FALSE, eval = FALSE>>=
p <- qplot(gr, ncol = 2)
print(p)
@ %def 
\begin{figure}[h!b!t!p]
  \centering
\includegraphics[width = 0.6\textwidth]{gr-nrow1.png}
  \caption{qplot use layout to control the graphics. Here when users set ncol = 2,
  it automatically wrap to two column when facet by default seqnames.}
  \label{fig:gr-layout-nrow}
\end{figure}


\subsubsection{Facetting}

Faceting in \ggbio{} is more restricted than in \ggplot{}:

\begin{itemize} \itemsep 0in
\item The facetting variable can only be \Rfunction{seqnames} or regions
  on the genome. So we limited the formula passing to \Rfunarg{facet},
  e.g something \~ seqnames, is accepted formula, you can change
  \emph{something} to variable name in the elementMetadata. But you
  cannot change the second part.
\item Sometimes, we need to view different regions, so we also have a
  \Rfunarg{facet\_gr} argument which accept a \Robject{GRanges}. If
  this is provided, it will override the default \textbf{seqnames} and use
  provided region to facet the graphics, which might be useful for
  different gene centric views.
\end{itemize}

Figure \ref{fig:facet.group} shows we could only specify the facet row
to be one the categorical variables in elementMetadata. 

% \begin{figure}[h!t!p]
%   \centering
@ 
<<facet-group, fig = FALSE, eval = FALSE>>=
  p <- qplot(gr, facet = group ~ seqnames)
  print(p)
@ %def 
%   \caption{Facet by group}
%   \label{fig:facet.group}
% \end{figure}
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-facet-group.png}
  \caption{Facet by group}
  \label{fig:facet.group}
\end{figure}

Figure \ref{fig:facet.gr} shows how to facet by \Rfunarg{facet\_gr}
arguments.

% \begin{figure}[h!t!p]
%   \centering
  
  @ 
<<facet-gr, fig = FALSE, eval = FALSE>>=
 gr.region <- GRanges(c("chr1", "chr2", "chr3"), 
  IRanges(c(100, 200, 250), 
  width = 70))
  p <- qplot(gr, facet_gr = gr.region, nrow = 1)
  print(p)  
@ %def 

%   \caption{Facet by regions}
%   \label{fig:facet.gr}
% \end{figure}
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-facet-gr.png}
  \caption{Facet by regions}
  \label{fig:facet.gr}
\end{figure}

\subsection{For \Robject{GRangesList} object}
It's just simply internally unlist the \Robject{GRangesList} object
and treat it as \Robject{GRanges} object. 

Since most time a \Robject{GRangesList} has a native structure to
describe a genomic model or alternative splicing, we make the default
automatically adding group information based on the listed data. We
assume each list contains a single isoform or a single model, so they
need to be shown on the same level. Then we also have
\Rfunarg{show.gaps} to control whether to show gaps or not, and
\Rfunarg{show.label} to control whether to show the group name or not.

If users want to control the graphic as \Robject{GRanges}, please
convert it to \Robject{GRanges} first, then ust \qplot{} to visualize
it.

\subsubsection{Alternative splicing and summary}
Here is a case study, how to use \qplot{} for \Robject{GRangesList} to
produce a splicing model and show summary on it. In the following data
from a \Robject{TransciptDb} object, and using \Rfunarg{freq} argument
to pass the summary information to the function.

It's convenient to get model from a \Robject{TranscriptDb} object,
it's already split by transcipt when you specify \Rfunarg{by} equals
\emph{tx}, and this will return a \Robject{GRangesList} object, with
name of transcript.

@ 
<<splice-grl, fig = FALSE, eval = FALSE>>=
data(genesymbol)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- Hsapiens_UCSC_hg19_knownGene_TxDb
exons <- exonsBy(txdb, by = "tx")
exons.rbm17 <- subsetByOverlaps(exons, genesymbol["RBM17"])
nms <- names(exons.rbm17)
freqs <- c(100, 200, 300)
names(freqs) <- nms
p.grl <- qplot(exons.rbm17, freq = freqs)
p.unlist <- qplot(unlist(exons.rbm17))
grid.arrange(p.grl, p.unlist, nrow = 2)
@ %def 
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.8\textwidth]{splice-two.png}
\caption{Alternative splicing summary from \Robject{GRangesList}
  compared to just \Robject{GRanges}. The top panel shows how to
  visualize alternative splicing with summary. The line width
  indicates evidence supporting each model. And the bottom plot shows
  if we simply convert it to \Robject{GRanges}, it's just stepping of
  intervals without considering any grouping information}
  \label{fig:facet.gr}
\end{figure}

In the future, we are going to support more types of graphics to
visualize alternative splicing. it's an active research field.

\subsection{For \Robject{IRanges} object}
Similar to \qplot{} for \Robject{GRanges}, supported geoms includes, 
\emph{full, segment, histogram, coverage.line, coverage.polygon, reduce}

% 
% \begin{figure}[h!t!p]
%   \centering
% @ 
<<iranges-plot, fig = FALSE, eval = FALSE>>=
ir <- ranges(gr[seqnames(gr) == "chr1"])
p1 <- qplot(ir) + opts(title = "full")
p2 <- qplot(ir, geom = "segment")+ opts(title = "segment")
p3 <- qplot(ir, geom = "coverage.line")+ opts(title = "coverage.line")
p4 <- qplot(ir, geom = "coverage.polygon")+ opts(title = "coverage.polygon")
p5 <- qplot(ir, geom = "reduce")+ opts(title = "reduce")
p6 <- qplot(ir, geom = "histogram")+ opts(title = "histogram")
png("iranges-plot.png", 600, 800)
grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 2)
dev.off()
@ %def 
%   \caption{IRanges geoms}
%   \label{fig:iranges-plot}
% \end{figure}
\begin{figure}[h!t!p]
  \centering
\includegraphics[width = 0.6\textwidth]{iranges-plot.png}
\caption{qplot for \Robject{IRanges}. Similar to \Robject{GRanges},
  but we don't have seqnames information about it}
  \label{fig:iranges-plot}
\end{figure}



\subsection{For \Robject{GappedAlignments} object}
Supportd geom includes:
\begin{description} \itemsep 0in
\item[gapped.pair] Consider junction reads information, and assign
  stepping levels based on that information, could be used to show
  junction. The \Rfunarg{show.junction} could control show the
  junction reads or not
\item[full] Show as the \emph{full} geom like for \Robject{GRanges}
  object, randomly assign stepping levels.
\end{description}


% \begin{figure}[h!p!t]
%   \centering
@ 
<<gapped-plot, fig = FALSE, eval = FALSE>>=
library(Rsamtools)
bamfile <- system.file("extdata", "SRR027894subRBM17.bam", package="biovizBase")
ga <- readBamGappedAlignments(bamfile, use.names = TRUE)
p1 <- qplot(ga)
p2 <- qplot(ga, show.junction = TRUE)
p3 <- qplot(ga, geom = "full")
grid.arrange(p1, p2, p3, ncol = 1)
@ %def 
% \caption{GappedAlignments virsualization. The one on the left shows
%   geom ``gapped.pair'', which try to put the one belongs to the same
%   read in the same step level, and make sure nothing falls in between,
%   this is usefull when show.junction = TRUE. The one on the right, is
%   use ``simple'' geom, which just show as formal GRanges.}
%   \label{fig:gapped-ori}
% \end{figure}
\begin{figure}[h!p!t]
  \centering
\includegraphics[width = 0.55\textwidth]{intro-gapped-plot}
\caption{GappedAlignments virsualization. The one on the left shows
  geom ``gapped.pair'', which try to put the one belongs to the same
  read in the same step level, and make sure nothing falls in between,
  this is usefull when show.junction = TRUE. The one on the right, is
  use ``simple'' geom, which just show as formal GRanges.}
  \label{fig:gapped-ori}
\end{figure}


% \begin{figure}[h!p!t]
%   \centering
@ 
<<gapped-plot-zoom, fig = FALSE, eval = FALSE>>=
p1 <- p1 + scale_x_continuous(limits = c(6134000, 6135000))
print(p1)
@ %def 
%   \caption{GappedAlignments virsualization: simple zoom in}
%   \label{fig:gapped-zoom}
% \end{figure}

\begin{figure}[h!p!t]
  \centering
\includegraphics[width = 0.8\textwidth]{intro-gapped-plot-zoom}
  \caption{GappedAlignments virsualization: simple zoom in}
  \label{fig:gapped-zoom}
\end{figure}


\subsection{For \Robject{BamFile} object}
Supported geoms includs:
\begin{description} \itemsep 0in
  \item[gapped.pair] Like for \Robject{GappedAlignments} object.
  \item[full] Like for \Robject{GappedAlignments} object.
  \item[fragment.length] \emph{NOTE:} This return a track.
  \item[coverage.line] like for \Robject{GRanges} object
  \item[coverage.polygon] like for \Robject{GRanges} object
  \item[mismatch] TODO.(underlying computation is finished)
  \item[read.summary] TODO.(underlying computation is finished)
\end{description}
\subsection{For \Robject{TranscriptDb} object}
Supported geoms including
\begin{description} \itemsep 0in
\item[full] Full model, trying to show all 5'-UTR, 3'-UTR, cds and introns in 
  different transcripts.
\item[single] Reduced model.
\end{description}

Figure \ref{fig:txdb} shows two tracks for a \Robject{TranscriptDb} object.

% \begin{figure}[h!t!b!p]
%   \centering
@ 
<<txdb-plot, fig = FALSE, eval = FALSE>>=
## exons <- exonsBy(txdb, by = "tx")
## exons.rbm17 <- subsetByOverlaps(exons, genesymbol["RBM17"])
p.full <- qplot(txdb, geom = "full", which = genesymbol["RBM17"])
p.single <- qplot(txdb, geom = "single", which = genesymbol["RBM17"])
tracks(p.full, p.single, heights = c(40, 10))
@ %def 
%   \caption{TranscriptDb visualization. First track showing full model, second track showing reduced one.}
%   \label{fig:txdb}
% \end{figure}


\subsection{For \Robject{BSgenome} object}
Package \Rpackage{BSgenome} provides infrastructure for
Biostrings-based genome data packages. And users could download many
full genome as provided by UCSC which stored in Biostrings objects
from metadata database in Bioconductor project website.

So \qplot{} function for this object tries to:

\begin{description} \itemsep 0in
\item[text] Showing nucleotides as text.
\item[segment] Showing nucleotides as color-coded segment.
\item[point] Showing nucleotides as color-coded point.
\item[rectangle] Showing nucleotides as color-coded rectangle.
\end{description}

Figure \ref{fig:BSgenome} shows four tracks(with four geom) for a
\Robject{BSgenome} object.
% \begin{figure}[h!t!p]
%   \centering
@ 
<<BSgenome-tracks, fig = FALSE, eval = FALSE>>=
library(BSgenome.Hsapiens.UCSC.hg19)
gr <- GRanges("chr1", IRanges(5e7, 5e7+50))
p1 <- qplot(Hsapiens, name = gr, geom = "text") +
  theme_bw()
p2 <- qplot(Hsapiens, name = gr, geom = "point") +
    theme_bw()
p3 <- qplot(Hsapiens, name = gr, geom = "segment") +
    theme_bw()
p4 <- qplot(Hsapiens, name = gr, geom = "rectangle") +
    theme_bw()
tracks(p1, p2, p3, p4)
@ %def 
%   \caption{BSgenome with four geoms, first one is text, second is point, third one is segment, and fourth one is rectangle

\begin{figure}[h!p!t]
  \centering
\includegraphics[width = 0.6\textwidth]{intro-BSgenome-tracks.png}
  \caption{BSgenome with four geoms, first one is text, second is point, third one is segment, and fourth one is rectangle}
  \label{fig:BSgenome}
\end{figure}



\section{Overview}
\emph{Bird Eye Overview} is useful to see the overal distribution of
certain events. For static graphic, we currently only support stacked
overview as ideogram, or for single chromosome.
\subsection{Stacked Overview}
Stacked overview is useful to visualzie the annotation across the
genome, you can use \Rfunction{plotOverview} function to directly plot
the result from \Rfunction{getIdeogram} for certain species. And you
could control wether to plot the cytoband or not.

Figure \ref{fig:plotOverview-cyto} shows how to plot stacked overview
with cytoband. We change the name to make the label more
clear. \Rfunction{renameSeqlevels} function from
\Rpackage{GenomicRanges} is a good choice.

% \begin{figure}[h!t!p]
%   \centering
@ 
<<plotOverview-cyto, fig = FALSE, eval = FALSE>>=
data(hg19IdeogramCyto)
## make shorter and clean labels
old.chrs <- seqnames(seqinfo(hg19IdeogramCyto))
new.chrs <- gsub("chr", "", old.chrs)
## lst <- as.list(new.chrs)
names(new.chrs) <- old.chrs
new.ideo <- renameSeqlevels(hg19IdeogramCyto, new.chrs)
p <- plotOverview(new.ideo, cytoband = TRUE)
print(p)
@ %def   
%   \caption{Stacked overview with cytoband}
%   \label{fig:plotOverview-cyto}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.6\textwidth]{intro-plotOverview-cyto.png}
  \caption{Stacked overview with cytoband}
  \label{fig:plotOverview-cyto}
\end{figure}




Clearly, it's not good for visualizing the annotation at the same
time, so we could plot it without cytoband. This accept a full
ideogram which will be reduced automatically. You could also just use
\textbf{hg19Ideogram} dataset.
% \begin{figure}[h!t!p]
  % \centering
@ 
<<plotOverview-nocyto, fig = FALSE, eval = FALSE>>=
p <- plotOverview(new.ideo, cytoband = FALSE)
print(p)
@ %def   
%   \caption{Stacked overview without cytoband}
%   \label{fig:plotOverview-nocyto}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.6\textwidth]{intro-plotOverview-nocyto.png}  
  \caption{Stacked overview without cytoband}
  \label{fig:plotOverview-nocyto}
\end{figure}

Then we could simply use \Rfunction{geom\_hotregion} function to read
in a \Robject{GRanges} object as other geoms(except they read in
\Robject{data.frame}). And use \textbf{+} to simply add a annotation
track on top with overview, they will automatically plot on the same
chromosome and on the same x scale.

Figure \ref{fig:plotOverview-nocyto-darned} shows an example
of subset of RNA editing set. 

\textbf{NOTE:} user need to make sure the \Rfunction{seqnames} are
consistency in two datas, otherwise you are going to make weird
graphics, because they can not be mapped in the right way.
% \begin{figure}[h!t!p]
%   \centering
@ 
<<plotOverview-nocyto-darned, fig = FALSE, eval = FALSE>>=
data(darned_hg19_subset500)
## rename 
old.chrs <- seqnames(seqinfo(darned_hg19_subset500))
new.chrs <- gsub("chr", "", old.chrs)
names(new.chrs) <- old.chrs
new.darned <- renameSeqlevels(darned_hg19_subset500, new.chrs)
p <- p + geom_hotregion(new.darned)
print(p)
@ %def   
% \caption{Stacked overview without cytoband and with subseted DARNED
%   data on it}
%   \label{fig:plotOverview-nocyto-darned}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.6\textwidth]{intro-plotOverview-nocyto-darned.png}    
\caption{Stacked overview without cytoband and with subseted DARNED
  data on it}
  \label{fig:plotOverview-nocyto-darned}
\end{figure}

We can also use \Rfunarg{color} argument to use color to indicate a
column in the elementMetadata.

Let's try to use color to indicate which exon region the editing site
is, \emph{3} means 3' UTR, \emph{5} means 5' UTR, \emph{C} means it's
\emph{CDS}, and \textbf{NA} indicate missing.

% \begin{figure}[h!t!p]
%   \centering
@ 
<<plotOverview-nocyto-darned-exon, fig = FALSE, eval = FALSE>>=

p <- plotOverview(new.ideo, cytoband = FALSE)
p <- p + geom_hotregion(new.darned, aes(color = exReg))
print(p)
@ %def   
% \caption{Stacked overview without cytoband and with subseted DARNED
%   data on it}
%   \label{fig:plotOverview-nocyto-darned}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.6\textwidth]{intro-plotOverview-nocyto-darned-exon.png}      
\caption{Stacked overview without cytoband and with subseted DARNED
  data on it}
  \label{fig:plotOverview-nocyto-darned-exon}
\end{figure}

% \begin{figure}[h!t!p]
%   \centering
@ 
<<plotSingleChrom, fig = FALSE, eval = FALSE>>=
p <- plotSingleChrom(hg19IdeogramCyto, subchr = "chr1")
print(p)
## you could also run the following code to make nice adjusted 
## overview
## vp1 <- viewport(width = 1, height = 0.14)
## p <- plotSingleChrom(hg19IdeogramCyto, subchr = "chr1")
## print(p, vp = vp1)
@ %def   
%   \caption{Single Chromosome as Ideogram}
%   \label{fig:plotSingleChrom}
% \end{figure}

\begin{figure}[h!t!p]
  \centering
  \includegraphics[height = .26in, width = 5in]{intro-plotSingleChrom.pdf}\\
  \includegraphics[height = .26in, width = 5in]{intro-plotSingleChrom-zoom.pdf}  
  \caption{Single Chromosome as Ideogram. The top plot shows simple single chromosome,
  and the bottom one shows the one with fixed zoom window.}
  \label{fig:plotSingleChrom}
\end{figure}


% \begin{figure}[h!t!p]
%   \centering
@ 
<<plotSingleChrom-zoom, fig = FALSE, eval = FALSE>>=
p <- plotSingleChrom(hg19IdeogramCyto, subchr = "chr1",
                zoom.region = c(1e8, 1.5e8))
print(p)
@ %def   
%   \caption{Single Chromosome as Ideogram with zoomed rectangle}
%   \label{fig:plotSingleChrom-zoom}
% \end{figure}

% \begin{figure}[h!t!p]
%   \centering
%   \includegraphics[width = 0.55\textwidth][height = 1in, width = 5in]{intro-plotSingleChrom-zoom.pdf}
%   \caption{Single Chromosome as Ideogram with zoomed rectangle}
%   \label{fig:plotSingleChrom-zoom}
% \end{figure}


\subsection{Circular Overview}
Circular view is inspired by the \software{Circos} project
\footnote{\url{http://circos.ca/}} which is essentially writen
\software{Perl}\footnote{\url{http://www.perl.org/}}.\software{Circos}
visualize data in a circular layout, originally starting from
visualize the genomic data, then extends to many other fields, turn
out to be an elegant and useful way to visualize some other
infomation.

The static version of circular view is not implemented in this pacakge
yet, but it's defintely in the TODO. For users who are really
interested in using a circular view in \R{}, we have a highly
experimental circular view in another package \visnab{}, which is
interactive visualization toolkit for genomic data.
\section{Building Tracks for Linear View}
In most genome browsers, they all have such a view that including many
tracks, could be any anntation data along genomic coordinate. So we
try to provide a convenient constructor for building tracks, which
here in this package is simply vertically binding of several
plots. It's essentially a \Rfunction{grid.arrange}. So if users want
to have more delicate control over their tracks, they need manipulate
the graphics in \ggplot{} level or grid levels.

\Rfunction{tracks} function has some extra features and limitations
compare to \Rfunction{grid.arrange}.
\begin{itemize} \itemsep 0in
\item Always sitting on genomic or protein space.
\item Always using ncol = 1 as default arguments.
\item For now, since the unbalanced legend and labels in \ggplot{} has
  been solved (maybe just I haven't found such features). We simply
  remove legend and y axis labels to make sure all tracks are aligned
  exactly in the same way.
\item Remove the x-axis for most track except the last one. 
\item Does the ajustment of margins for you automatically.
\item Doesn't like \qplot{}, tracks doesn't return \Robject{ggplot}
  object. so processing your plot before you pass them to
  \Rfunction{tracks}.
\end{itemize}

We have already demonstrate how to use \Rfunction{tracks} in the
previous sections.

\section{Question-oriented Specific Graphics}
\subsection{Fragment Length}
To be updated.
@ 
<<frag-length, fig = FALSE, eval = FALSE>>=
gr.rbm <- genesymbol["RBM17"]
exs <- exonsByOverlaps(txdb, gr.rbm, colum = "tx_id")
qplot(BamFile(bamfile), model = exs, geom = "fragment.length", group.name = "tx_id")
@ %def   


\subsection{Mismatch Summary}
For NGS(Next generation sequencing) data, sometimes instead of showing
all the alignments, we hope to show just summary information for
particular region. And mismatch summary is one of those interesting
summaries. 

\Rfunction{plotMismatchSum} shows only mismatched read counts as color
coded stacked barchart or with coverage as background. We also
implement this as one geom for certain object, such \Robject{BamFile}
and \Robject{GRanges}, so you could use \qplot{} for simply generating
some mismatch summary. When the object is \Robject{GRanges}. we check
inside the function to see if the \Robject{GRanges} is from
\Rfunction{pileupGRangesAsVariantTable} or not, or it need to contains
certain column required for plotting mismatch summary.

@ 
<<mismatch-plot, fig = FALSE, eval = FALSE>>=
bamfile <- system.file("extdata", "SRR027894subRBM17.bam", package="biovizBase")
gr <- GRanges("chr10", IRanges(6134000, 6135000))
test <- pileupAsGRanges(bamfile, region = gr)
test.match <- pileupGRangesAsVariantTable(test, Hsapiens)
## use plotMismatchSum directly
pmis1 <- plotMismatchSum(test.match, show.coverage = FALSE)
pmis2 <- plotMismatchSum(test.match, show.coverage = TRUE)
grid.arrange(pmis1, pmis2, ncol = 1)
## we can also use generic qplot function
## use qplot generic function
p <- qplot(test.match, geom = "mismatch.summary")
library(Rsamtools)
## for character
p <- qplot(bamfile, which = gr, bsgenome = Hsapiens,
      geom = "mismatch.summary", show.coverage = TRUE)
## for BamFile
p <- qplot(BamFile(bamfile), which = gr, bsgenome = Hsapiens,
      geom = "mismatch.summary", show.coverage = TRUE)
@ %def 

\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.7\textwidth, width = 5in]{mismatch.png}  
  \caption{Mismatch summary: The top one shows only mismatched counts
    without showing coverage, and the bottom one shows coverage in
    gray color as background. For each position, reads that as same as
    reference will be shown as gray. And we only color the reads that
    is mismatch from the reference and color-coded by default. }
  \label{fig:mismatch}
\end{figure}


\subsection{Manhattan Plots for SNP data}
A Manhattan plot is special scatter plot used to visualize data with a
large number of data points, with a distribute of some higher-magnitude
values. For example, in the GWAS(genome-wide association studies). Here
we mainly focus on GWAS Manhattan plots. X-axis is genomic coordinates
and Y-axis is negative logarithm of the associated P-value for each
single nucleotide polymorphism. So higher the value, more stronger the
association they are.

Here we simulate some SNP data, as Figure \ref{fig:manhattan}shows,
you can plot it in different ways.

Default is assigning color for all chromosomes, and use a free
space. Users can have more delicate control such as adding title,
using customized two-color scheme, and adding cut off, removing
legend.. Please refer to the manual.

@ 
<<manhattan-plot, fig = FALSE, eval = FALSE>>=
data(hg19IdeogramCyto)
data(hg19Ideogram)
chrs <- as.character(levels(seqnames(hg19IdeogramCyto)))
seqlths <- seqlengths(hg19Ideogram)[chrs]
set.seed(1)
nchr <- length(chrs)
nsnps <- 1000
gr.snp <- GRanges(rep(chrs,each=nsnps),
             IRanges(start = do.call(c, lapply(chrs, function(chr){
               N <- seqlths[chr]
               runif(nsnps,1,N)
             })), width = 1),
             SNP=sapply(1:(nchr*nsnps), function(x) paste("rs",x,sep='')),
             pvalue =  -log10(runif(nchr*nsnps))
             )

## processing the name, to make it shorter
nms <- seqnames(seqinfo(gr.snp))
nms.new <- gsub("chr", "", nms)
names(nms.new) <- nms
gr.snp <- renameSeqlevels(gr.snp, nms.new)
## plottting
pm1 <- plotManhattan(gr.snp, y = pvalue)
pm2 <- plotManhattan(gr.snp, y = pvalue, color.type = "seqnames")
pm3 <- plotManhattan(gr.snp, y = pvalue, color.type = "twocolor", title = "SNP",
                     cutoff = c(4, 5), cutoff.color = "blue", cutoff.size = 1)
pm4 <- plotManhattan(gr.snp, y = pvalue, color.type = "twocolor", 
                     two.color = c("black", "gray50"))
pm5 <- plotManhattan(gr.snp, y = pvalue, scale = "fixed", space = "fixed")
grid.arrange(pm1, pm2, pm3, pm4, pm5, ncol = 1)
@ %def 


\begin{figure}[h!t!p]
  \centering
  \includegraphics[width = 0.7\textwidth, width = 5in]{manhattan.png}  
  \caption{Manhattan plot for simulated SNP data set. The first row is
    default.  Second row shows color based on seqnames. Third row
    shows two colors only, use default color scheme, and adding cutoff
    at the same time. The fourth row use customized two colors. The
    fifth row use fixed space which default is adjusted on data
    range.}
  \label{fig:manhattan}
\end{figure}

\section{Session Info}
@ 
<<sessionInfo>>=
sessionInfo()
@ %def 

% DI: I think you need to say something about color schemes, choices, and how missings are colored.

% DI: Need to add references, ggplot2 book, .... list of referenced R packages, ...
% Do oyu need to acknowledge Genentech?
\end{document}
